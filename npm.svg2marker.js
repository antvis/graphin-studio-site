(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{299:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export path2marker */\n/* unused harmony export svg2marker */\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var svg_path_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(300);\n/* harmony import */ var svg_path_parser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(svg_path_parser__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance");\n}\n\nvar parser = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["memoize"])(svg_path_parser__WEBPACK_IMPORTED_MODULE_1___default.a);\n/**\r\n *  Return function to register a Marker Symbol for give SVG Path\r\n *\r\n * @param svgPath SVG Path string\r\n * @param viewBoxWidth SVG view box width, default to 1024\r\n * @param viewBoxHeight SVG view box height, default to 1024\r\n */\n\nfunction path2marker(svgPath) {\n  var viewBoxWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n  var viewBoxHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1014;\n  return function (x, y, r) {\n    var paths = parser(svgPath);\n    return paths.map(function (path) {\n      var arr = [];\n      arr.push(path.relative === true ? path.code.toLowerCase() : path.code.toUpperCase());\n      var pairs = [[path.x1, path.y1], [path.x2, path.y2], [path.x, path.y]];\n      pairs.forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            px = _pair[0],\n            py = _pair[1];\n\n        if (px !== undefined) {\n          arr.push(path.relative === true ? px / viewBoxWidth * 2 * r : x - r + r * 2 * (px / viewBoxWidth));\n        }\n\n        if (py !== undefined) {\n          arr.push(path.relative === true ? py / viewBoxHeight * 2 * r : y - r + r * 2 * (py / viewBoxHeight));\n        }\n      });\n      return arr;\n    });\n  };\n}\n/**\r\n * Return function to register a Marker symbol for give svg file\r\n *\r\n * @param icon SVG file content\r\n */\n\nfunction svg2marker(icon) {\n  var pathMatch = /<path\\s+d="(.*?)"/i.exec(icon);\n  var viewBoxMatch = /viewBox="\\d+\\s+\\d+\\s+(\\d+)\\s+(\\d+)"/i.exec(icon);\n\n  if (pathMatch === null || pathMatch.length < 2) {\n    return function () {\n      return [];\n    };\n  }\n\n  var width = 1024;\n  var height = 1024;\n\n  if (viewBoxMatch !== null && viewBoxMatch.length >= 3) {\n    if (!isNaN(parseInt(viewBoxMatch[1], 10))) {\n      width = parseInt(viewBoxMatch[1], 10);\n    }\n\n    if (!isNaN(parseInt(viewBoxMatch[2], 10))) {\n      height = parseInt(viewBoxMatch[2], 10);\n    }\n  }\n\n  return path2marker(pathMatch[1], width, height);\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (svg2marker);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dyYXBoaW4vbm9kZV9tb2R1bGVzL3N2ZzJtYXJrZXIvZGlzdC9pbmRleC5lc20uanM/OTcwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBzdmdQYXRoUGFyc2VyIGZyb20gJ3N2Zy1wYXRoLXBhcnNlcic7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbnZhciBwYXJzZXIgPSBtZW1vaXplKHN2Z1BhdGhQYXJzZXIpO1xuLyoqXHJcbiAqICBSZXR1cm4gZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYSBNYXJrZXIgU3ltYm9sIGZvciBnaXZlIFNWRyBQYXRoXHJcbiAqXHJcbiAqIEBwYXJhbSBzdmdQYXRoIFNWRyBQYXRoIHN0cmluZ1xyXG4gKiBAcGFyYW0gdmlld0JveFdpZHRoIFNWRyB2aWV3IGJveCB3aWR0aCwgZGVmYXVsdCB0byAxMDI0XHJcbiAqIEBwYXJhbSB2aWV3Qm94SGVpZ2h0IFNWRyB2aWV3IGJveCBoZWlnaHQsIGRlZmF1bHQgdG8gMTAyNFxyXG4gKi9cblxuZnVuY3Rpb24gcGF0aDJtYXJrZXIoc3ZnUGF0aCkge1xuICB2YXIgdmlld0JveFdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDI0O1xuICB2YXIgdmlld0JveEhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTAxNDtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgdmFyIHBhdGhzID0gcGFyc2VyKHN2Z1BhdGgpO1xuICAgIHJldHVybiBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGFyci5wdXNoKHBhdGgucmVsYXRpdmUgPT09IHRydWUgPyBwYXRoLmNvZGUudG9Mb3dlckNhc2UoKSA6IHBhdGguY29kZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIHZhciBwYWlycyA9IFtbcGF0aC54MSwgcGF0aC55MV0sIFtwYXRoLngyLCBwYXRoLnkyXSwgW3BhdGgueCwgcGF0aC55XV07XG4gICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBfcGFpciA9IF9zbGljZWRUb0FycmF5KHBhaXIsIDIpLFxuICAgICAgICAgICAgcHggPSBfcGFpclswXSxcbiAgICAgICAgICAgIHB5ID0gX3BhaXJbMV07XG5cbiAgICAgICAgaWYgKHB4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhcnIucHVzaChwYXRoLnJlbGF0aXZlID09PSB0cnVlID8gcHggLyB2aWV3Qm94V2lkdGggKiAyICogciA6IHggLSByICsgciAqIDIgKiAocHggLyB2aWV3Qm94V2lkdGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChweSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXJyLnB1c2gocGF0aC5yZWxhdGl2ZSA9PT0gdHJ1ZSA/IHB5IC8gdmlld0JveEhlaWdodCAqIDIgKiByIDogeSAtIHIgKyByICogMiAqIChweSAvIHZpZXdCb3hIZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXHJcbiAqIFJldHVybiBmdW5jdGlvbiB0byByZWdpc3RlciBhIE1hcmtlciBzeW1ib2wgZm9yIGdpdmUgc3ZnIGZpbGVcclxuICpcclxuICogQHBhcmFtIGljb24gU1ZHIGZpbGUgY29udGVudFxyXG4gKi9cblxuZnVuY3Rpb24gc3ZnMm1hcmtlcihpY29uKSB7XG4gIHZhciBwYXRoTWF0Y2ggPSAvPHBhdGhcXHMrZD1cIiguKj8pXCIvaS5leGVjKGljb24pO1xuICB2YXIgdmlld0JveE1hdGNoID0gL3ZpZXdCb3g9XCJcXGQrXFxzK1xcZCtcXHMrKFxcZCspXFxzKyhcXGQrKVwiL2kuZXhlYyhpY29uKTtcblxuICBpZiAocGF0aE1hdGNoID09PSBudWxsIHx8IHBhdGhNYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdpZHRoID0gMTAyNDtcbiAgdmFyIGhlaWdodCA9IDEwMjQ7XG5cbiAgaWYgKHZpZXdCb3hNYXRjaCAhPT0gbnVsbCAmJiB2aWV3Qm94TWF0Y2gubGVuZ3RoID49IDMpIHtcbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHZpZXdCb3hNYXRjaFsxXSwgMTApKSkge1xuICAgICAgd2lkdGggPSBwYXJzZUludCh2aWV3Qm94TWF0Y2hbMV0sIDEwKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHZpZXdCb3hNYXRjaFsyXSwgMTApKSkge1xuICAgICAgaGVpZ2h0ID0gcGFyc2VJbnQodmlld0JveE1hdGNoWzJdLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGgybWFya2VyKHBhdGhNYXRjaFsxXSwgd2lkdGgsIGhlaWdodCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN2ZzJtYXJrZXI7XG5leHBvcnQgeyBwYXRoMm1hcmtlciwgc3ZnMm1hcmtlciB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///299\n')}}]);